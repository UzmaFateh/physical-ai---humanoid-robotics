# Qdrant Schema Design: RAG Chatbot

## Collection Design

### Collection Name
`doc_chunks`

### Vector Configuration
- **Vector Size**: 1536 (compatible with OpenAI text-embedding-ada-002 or similar models)
- **Distance Function**: Cosine
- **Datatype**: float32

### Collection Creation Parameters
```json
{
  "collection_name": "doc_chunks",
  "vectors_config": {
    "size": 1536,
    "distance": "Cosine",
    "datatype": "float32"
  },
  "hnsw_config": {
    "m": 16,
    "ef_construct": 100,
    "full_scan_threshold": 10000,
    "max_indexing_threads": 0,
    "on_disk": false
  },
  "optimizer_config": {
    "deleted_threshold": 0.2,
    "vacuum_min_vector_number": 1000,
    "default_segment_number": 0,
    "max_segment_size": null,
    "memmap_threshold": null,
    "indexing_threshold": 20000,
    "flush_interval_sec": 10,
    "max_optimization_threads": 1
  },
  "quantization_config": {
    "scalar": {
      "type": "int8",
      "quantile": 0.99,
      "always_ram": true
    }
  }
}
```

## Payload Schema

### Payload Structure
```json
{
  "content": "Text content of the document chunk",
  "source_url": "URL where the content originated",
  "page_title": "Title of the source page",
  "section": "Section or heading name",
  "chunk_order": 0,
  "metadata": {
    "tags": ["tag1", "tag2"],
    "last_updated": "2025-12-09T00:00:00Z",
    "word_count": 150,
    "source_type": "documentation|blog|faq",
    "language": "en"
  }
}
```

### Payload Field Indexing

#### Indexed Fields
- `source_url`: Keyword index for filtering by document source
- `page_title`: Keyword index for searching by page title
- `section`: Keyword index for filtering by section/heading
- `chunk_order`: Integer index for ordering chunks within a document
- `metadata.tags`: Keyword index for tag-based filtering
- `metadata.source_type`: Keyword index for filtering by content type
- `metadata.language`: Keyword index for language filtering

#### Text Fields (for full-text search)
- `content`: Full-text index for searching within content (if supported)

## Point ID Strategy

### ID Format
UUID4 format for unique identification across all collections

### ID Generation
- Use UUID4 to ensure global uniqueness
- Generated by the application layer before insertion
- Allows for tracking and reference across systems

## Search Configuration

### Default Search Parameters
```json
{
  "limit": 5,
  "with_payload": true,
  "with_vectors": false,
  "score_threshold": 0.5,
  "offset": 0,
  "filter": {
    "must": [],
    "should": [],
    "must_not": []
  }
}
```

### Filter Examples

#### Filter by Source URL
```json
{
  "filter": {
    "must": [
      {
        "key": "source_url",
        "match": {
          "value": "https://example.com/docs/introduction"
        }
      }
    ]
  }
}
```

#### Filter by Tags
```json
{
  "filter": {
    "must": [
      {
        "key": "metadata.tags",
        "match": {
          "any": ["api", "reference"]
        }
      }
    ]
  }
}
```

#### Filter by Source Type
```json
{
  "filter": {
    "must": [
      {
        "key": "metadata.source_type",
        "match": {
          "value": "documentation"
        }
      }
    ]
  }
}
```

## Collection Management

### Recommended Collection Settings

#### Production Settings
- **Replication Factor**: 2 (for high availability)
- **Write Consistency Factor**: 2 (to ensure consistency)
- **Read Consistency Factor**: 1 (for performance)

#### Performance Tuning
- **HNSW M parameter**: 16 (balance between speed and accuracy)
- **HNSW ef_construct**: 100 (construction quality)
- **Quantization**: Enable scalar quantization to reduce memory usage
- **Segment Size**: Use default optimization settings

### Backup and Recovery
- Enable Qdrant Cloud's built-in backup features
- Implement application-level backup for critical metadata
- Regular export of collection schema and configuration

## API Usage Patterns

### Adding Points
```python
from qdrant_client import QdrantClient
from qdrant_client.http import models

client = QdrantClient(
    url=os.getenv("QDRANT_URL"),
    api_key=os.getenv("QDRANT_API_KEY")
)

# Create points with embeddings
points = [
    models.PointStruct(
        id=str(uuid.uuid4()),
        vector=embedding_vector,
        payload={
            "content": chunk_text,
            "source_url": source_url,
            "page_title": page_title,
            "section": section,
            "chunk_order": order,
            "metadata": {
                "tags": tags,
                "last_updated": datetime.utcnow().isoformat(),
                "word_count": len(chunk_text.split()),
                "source_type": "documentation"
            }
        }
    )
]

client.upsert(
    collection_name="doc_chunks",
    points=points
)
```

### Search Points
```python
def search_similar_chunks(query_embedding, top_k=5, source_url=None, tags=None):
    # Prepare filters
    filter_conditions = []

    if source_url:
        filter_conditions.append(
            models.FieldCondition(
                key="source_url",
                match=models.MatchValue(value=source_url)
            )
        )

    if tags:
        filter_conditions.append(
            models.FieldCondition(
                key="metadata.tags",
                match=models.MatchAny(any=tags)
            )
        )

    search_filter = models.Filter(must=filter_conditions) if filter_conditions else None

    # Perform search
    search_results = client.search(
        collection_name="doc_chunks",
        query_vector=query_embedding,
        query_filter=search_filter,
        limit=top_k,
        with_payload=True,
        score_threshold=0.5
    )

    return search_results
```

### Updating Points
```python
def update_chunk_content(point_id, new_content, new_embedding):
    client.upsert(
        collection_name="doc_chunks",
        points=[
            models.PointStruct(
                id=point_id,
                vector=new_embedding,
                payload={
                    "content": new_content,
                    # Include other unchanged payload fields
                }
            )
        ]
    )
```

### Deleting Points
```python
def delete_chunks_by_url(source_url):
    client.delete(
        collection_name="doc_chunks",
        points_selector=models.FilterSelector(
            filter=models.Filter(
                must=[
                    models.FieldCondition(
                        key="source_url",
                        match=models.MatchValue(value=source_url)
                    )
                ]
            )
        )
    )
```

## Performance Considerations

### Indexing Strategy
- Use keyword indexes for frequently filtered fields
- Implement composite filters for complex queries
- Consider separate collections for different content types if needed

### Memory Management
- Enable quantization to reduce memory footprint
- Monitor collection size and implement archiving if needed
- Use appropriate hardware tier for expected data volume

### Query Optimization
- Use score thresholds to filter out low-quality matches
- Implement pagination for large result sets
- Cache frequently accessed content for better performance
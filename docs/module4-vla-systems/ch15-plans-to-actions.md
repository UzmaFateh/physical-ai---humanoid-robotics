---
sidebar_position: 3
---

# Chapter 15: Converting LLM Plans to Executable Actions

## Introduction to Plan Execution

Converting high-level plans generated by Large Language Models into executable robotic actions is a critical component of Vision-Language-Action (VLA) systems. This process involves:

1. **Action grounding**: Converting abstract actions to specific robot commands
2. **Constraint checking**: Ensuring actions are feasible given robot and environment constraints
3. **Parameter mapping**: Translating high-level specifications to low-level parameters
4. **Execution monitoring**: Tracking plan execution and handling failures
5. **Feedback integration**: Updating plans based on execution results

## Action Grounding and Feasibility Checking

```python
# action_grounding.py
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Pose, Twist, Point
from sensor_msgs.msg import LaserScan, Image
from nav_msgs.msg import OccupancyGrid
from std_msgs.msg import String, Bool
from tf2_ros import TransformListener, Buffer
from typing import Dict, List, Optional, Any
import numpy as np
import json

class ActionGrounding:
    """Converts abstract LLM actions to executable robot commands."""

    def __init__(self, robot_specs: Dict[str, Any]):
        """
        Initialize action grounding with robot specifications.

        Args:
            robot_specs: Dictionary containing robot capabilities and constraints
        """
        self.robot_specs = robot_specs
        self.action_mapping = {
            'navigate_to': self._ground_navigate_to,
            'pick_up': self._ground_pick_up,
            'place': self._ground_place,
            'push': self._ground_push,
            'rotate': self._ground_rotate,
            'stop': self._ground_stop,
            'report': self._ground_report,
            'wait': self._ground_wait
        }

    def ground_action(self, action: Dict[str, Any], environment_state: Dict[str, Any]) -> Optional[List[Dict[str, Any]]]:
        """
        Ground an abstract action to executable commands.

        Args:
            action: Abstract action from LLM
            environment_state: Current environment state

        Returns:
            List of executable commands or None if infeasible
        """
        action_type = action.get('action', 'unknown')

        if action_type not in self.action_mapping:
            print(f"Unknown action type: {action_type}")
            return None

        # Check feasibility
        if not self._check_action_feasibility(action, environment_state):
            print(f"Action not feasible: {action}")
            return None

        # Ground the action
        return self.action_mapping[action_type](action, environment_state)

    def _check_action_feasibility(self, action: Dict, env_state: Dict) -> bool:
        """Check if an action is feasible given current state."""
        action_type = action.get('action', 'unknown')

        # Check robot battery
        battery_level = env_state.get('robot_state', {}).get('battery_level', 1.0)
        if battery_level < 0.1:  # Critical battery level
            if action_type in ['navigate_to', 'pick_up', 'place']:
                return False

        # Check robot capabilities
        available_actions = env_state.get('robot_state', {}).get('available_actions', [])
        if action_type not in available_actions:
            return False

        # Check specific constraints
        if action_type == 'navigate_to':
            target = action.get('target')
            if target and not self._check_navigation_feasibility(target, env_state):
                return False
        elif action_type == 'pick_up':
            target = action.get('target')
            if target and not self._check_manipulation_feasibility(target, env_state):
                return False

        return True

    def _check_navigation_feasibility(self, target: str, env_state: Dict) -> bool:
        """Check if navigation to target is feasible."""
        # Check if target location is known
        if 'locations' in env_state:
            if target not in env_state['locations']:
                # Try to find target in object locations
                for obj_id, obj_info in env_state.get('objects', {}).items():
                    if target.lower() in obj_info.get('name', '').lower():
                        return True
                return False
        return True

    def _check_manipulation_feasibility(self, target: str, env_state: Dict) -> bool:
        """Check if manipulation of target is feasible."""
        # Check if target object exists and is accessible
        for obj_id, obj_info in env_state.get('objects', {}).items():
            if target.lower() in obj_info.get('name', '').lower():
                # Check if object is reachable
                obj_pos = obj_info.get('position', [0, 0, 0])
                robot_pos = env_state.get('robot_state', {}).get('position', [0, 0, 0])

                # Calculate distance
                distance = np.linalg.norm(np.array(obj_pos) - np.array(robot_pos))

                # Check if within manipulation range
                max_reach = self.robot_specs.get('manipulation_range', 1.0)
                return distance <= max_reach

        return False

    def _ground_navigate_to(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground navigation action to specific commands."""
        target = action.get('target', action.get('location', 'unknown'))
        commands = []

        # Find target location
        target_pose = self._find_target_location(target, env_state)
        if target_pose is None:
            # If location not found, try to find object with that name
            target_pose = self._find_object_location(target, env_state)

        if target_pose is not None:
            # Generate navigation command
            commands.append({
                'type': 'navigation_goal',
                'target_pose': target_pose,
                'approach_distance': action.get('approach_distance', 0.5),
                'description': f'Navigate to {target}'
            })
        else:
            # If target not found, ask for clarification
            commands.append({
                'type': 'request_info',
                'request': f'Where is {target}?',
                'description': f'Unknown location: {target}'
            })

        return commands

    def _ground_pick_up(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground pick up action to specific commands."""
        target = action.get('target', 'unknown')
        commands = []

        # Find target object
        obj_info = self._find_object_info(target, env_state)
        if obj_info is not None:
            obj_pose = obj_info.get('position', [0, 0, 0])

            # Approach object
            commands.append({
                'type': 'navigation_goal',
                'target_pose': {
                    'position': [obj_pose[0] - 0.3, obj_pose[1], obj_pose[2]],  # 30cm in front
                    'orientation': [0, 0, 0, 1]
                },
                'description': f'Approach {target} for pickup'
            })

            # Execute pickup
            commands.append({
                'type': 'gripper_command',
                'command': 'close',
                'description': f'Pick up {target}'
            })

            # Update robot state
            commands.append({
                'type': 'update_robot_state',
                'attached_object': target,
                'description': f'Attached {target} to robot'
            })
        else:
            commands.append({
                'type': 'request_info',
                'request': f'Where is {target}?',
                'description': f'Object {target} not found'
            })

        return commands

    def _ground_place(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground place action to specific commands."""
        target_obj = action.get('target', 'unknown')
        location = action.get('location', 'default')

        commands = []

        # Check if robot has object to place
        attached_objects = env_state.get('robot_state', {}).get('attached_objects', [])
        if target_obj not in attached_objects:
            commands.append({
                'type': 'error',
                'message': f'Robot does not have {target_obj}',
                'description': f'Cannot place {target_obj} - not attached'
            })
            return commands

        # Find placement location
        place_pose = self._find_target_location(location, env_state)
        if place_pose is None:
            # Use default placement location (current position + offset)
            robot_pos = env_state.get('robot_state', {}).get('position', [0, 0, 0])
            place_pose = {
                'position': [robot_pos[0] + 0.5, robot_pos[1], robot_pos[2]],  # 50cm ahead
                'orientation': [0, 0, 0, 1]
            }

        # Navigate to placement location
        commands.append({
            'type': 'navigation_goal',
            'target_pose': place_pose,
            'description': f'Navigate to place {target_obj} at {location}'
        })

        # Execute placement
        commands.append({
            'type': 'gripper_command',
            'command': 'open',
            'description': f'Place {target_obj}'
        })

        # Update robot state
        commands.append({
            'type': 'update_robot_state',
            'detach_object': target_obj,
            'description': f'Detached {target_obj} from robot'
        })

        return commands

    def _ground_push(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground push action to specific commands."""
        target = action.get('target', 'unknown')
        direction = action.get('direction', 'forward')

        commands = []

        # Find target object
        obj_info = self._find_object_info(target, env_state)
        if obj_info is not None:
            obj_pose = obj_info.get('position', [0, 0, 0])
            robot_pos = env_state.get('robot_state', {}).get('position', [0, 0, 0])

            # Calculate approach position
            approach_offset = 0.3  # 30cm from object
            approach_pos = [obj_pose[0], obj_pose[1], obj_pose[2]]

            if direction == 'forward':
                approach_pos[0] -= approach_offset
            elif direction == 'backward':
                approach_pos[0] += approach_offset
            elif direction == 'left':
                approach_pos[1] -= approach_offset
            elif direction == 'right':
                approach_pos[1] += approach_offset

            # Navigate to push position
            commands.append({
                'type': 'navigation_goal',
                'target_pose': {
                    'position': approach_pos,
                    'orientation': self._calculate_orientation(robot_pos, obj_pose)
                },
                'description': f'Approach {target} to push {direction}'
            })

            # Execute push (move forward slightly)
            commands.append({
                'type': 'motion_command',
                'linear_x': 0.2,  # Move forward 20cm
                'duration': 2.0,
                'description': f'Push {target}'
            })
        else:
            commands.append({
                'type': 'request_info',
                'request': f'Where is {target}?',
                'description': f'Object {target} not found for pushing'
            })

        return commands

    def _ground_rotate(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground rotation action to specific commands."""
        direction = action.get('direction', 'left')
        angle = action.get('angle', 90)  # degrees

        commands = []

        angular_vel = self.robot_specs.get('max_angular_velocity', 0.5)
        if direction == 'right':
            angular_vel = -angular_vel

        # Convert angle to time (simplified)
        rotation_time = (angle * np.pi / 180) / abs(angular_vel)

        commands.append({
            'type': 'velocity_command',
            'linear_x': 0.0,
            'angular_z': angular_vel,
            'duration': rotation_time,
            'description': f'Rotate {angle} degrees to the {direction}'
        })

        return commands

    def _ground_stop(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground stop action to specific commands."""
        return [{
            'type': 'velocity_command',
            'linear_x': 0.0,
            'angular_z': 0.0,
            'duration': 0.0,
            'description': 'Stop all motion'
        }]

    def _ground_report(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground report action to specific commands."""
        message = action.get('message', 'Status report')
        return [{
            'type': 'speak',
            'message': message,
            'description': f'Report: {message}'
        }]

    def _ground_wait(self, action: Dict, env_state: Dict) -> List[Dict]:
        """Ground wait action to specific commands."""
        duration = action.get('duration', 1.0)
        return [{
            'type': 'wait',
            'duration': duration,
            'description': f'Wait for {duration} seconds'
        }]

    def _find_target_location(self, target: str, env_state: Dict) -> Optional[Dict]:
        """Find a named location in the environment."""
        locations = env_state.get('locations', {})
        for loc_name, loc_pose in locations.items():
            if target.lower() in loc_name.lower():
                return loc_pose
        return None

    def _find_object_location(self, target: str, env_state: Dict) -> Optional[Dict]:
        """Find an object's location in the environment."""
        objects = env_state.get('objects', {})
        for obj_id, obj_info in objects.items():
            if target.lower() in obj_info.get('name', '').lower():
                pos = obj_info.get('position', [0, 0, 0])
                return {
                    'position': pos,
                    'orientation': [0, 0, 0, 1]  # Default orientation
                }
        return None

    def _find_object_info(self, target: str, env_state: Dict) -> Optional[Dict]:
        """Find complete object information."""
        objects = env_state.get('objects', {})
        for obj_id, obj_info in objects.items():
            if target.lower() in obj_info.get('name', '').lower():
                return obj_info
        return None

    def _calculate_orientation(self, from_pos: List[float], to_pos: List[float]) -> List[float]:
        """Calculate orientation to face a target position."""
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]
        yaw = np.arctan2(dy, dx)

        # Convert yaw to quaternion
        cy = np.cos(yaw * 0.5)
        sy = np.sin(yaw * 0.5)
        return [0, 0, sy, cy]
```

## Plan Execution and Monitoring

```python
# plan_execution.py
import asyncio
import threading
import time
from enum import Enum
from typing import Dict, List, Optional, Callable
import json

class ExecutionStatus(Enum):
    """Status of plan execution."""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"

class PlanExecutor:
    """Executes grounded plans and monitors execution."""

    def __init__(self, action_grounding: ActionGrounding):
        self.action_grounding = action_grounding
        self.current_plan = None
        self.current_status = ExecutionStatus.PENDING
        self.current_step = 0
        self.execution_history = []
        self.callbacks = {
            'step_started': [],
            'step_completed': [],
            'plan_completed': [],
            'error_occurred': []
        }

    def execute_plan(self, plan: List[Dict], env_state: Dict) -> ExecutionStatus:
        """
        Execute a plan with monitoring and error handling.

        Args:
            plan: List of actions from LLM
            env_state: Current environment state

        Returns:
            Final execution status
        """
        self.current_plan = plan
        self.current_status = ExecutionStatus.RUNNING
        self.current_step = 0
        self.execution_history = []

        try:
            while self.current_step < len(plan) and self.current_status == ExecutionStatus.RUNNING:
                action = plan[self.current_step]

                # Ground the action
                grounded_commands = self.action_grounding.ground_action(action, env_state)

                if grounded_commands is None:
                    self._handle_error(f"Could not ground action: {action}")
                    self.current_status = ExecutionStatus.FAILED
                    break

                # Execute grounded commands
                for cmd in grounded_commands:
                    if not self._execute_command(cmd):
                        self._handle_error(f"Command failed: {cmd}")
                        self.current_status = ExecutionStatus.FAILED
                        break

                if self.current_status == ExecutionStatus.FAILED:
                    break

                # Update step and notify
                self.current_step += 1
                self._notify_callbacks('step_completed', {
                    'step': self.current_step - 1,
                    'action': action,
                    'status': 'completed'
                })

            # Final status
            if self.current_status == ExecutionStatus.RUNNING:
                self.current_status = ExecutionStatus.SUCCESS

        except Exception as e:
            self._handle_error(f"Plan execution error: {e}")
            self.current_status = ExecutionStatus.FAILED

        finally:
            self._notify_callbacks('plan_completed', {
                'status': self.current_status.value,
                'steps_completed': self.current_step,
                'total_steps': len(plan) if plan else 0
            })

        return self.current_status

    def _execute_command(self, command: Dict) -> bool:
        """Execute a single grounded command."""
        cmd_type = command.get('type', 'unknown')

        # In a real implementation, this would interface with the robot
        # For simulation, we'll just return success after a delay
        try:
            if cmd_type == 'navigation_goal':
                return self._execute_navigation(command)
            elif cmd_type == 'gripper_command':
                return self._execute_gripper(command)
            elif cmd_type == 'velocity_command':
                return self._execute_velocity(command)
            elif cmd_type == 'speak':
                return self._execute_speak(command)
            elif cmd_type == 'wait':
                return self._execute_wait(command)
            elif cmd_type == 'request_info':
                return self._execute_request_info(command)
            elif cmd_type == 'update_robot_state':
                return self._execute_update_robot_state(command)
            else:
                print(f"Unknown command type: {cmd_type}")
                return False

        except Exception as e:
            print(f"Error executing command {command}: {e}")
            return False

    def _execute_navigation(self, command: Dict) -> bool:
        """Execute navigation command."""
        print(f"Navigating to: {command.get('target_pose')}")

        # Simulate navigation delay
        time.sleep(1.0)

        # In real implementation, this would:
        # 1. Send navigation goal to move_base
        # 2. Monitor progress
        # 3. Handle navigation failures
        return True

    def _execute_gripper(self, command: Dict) -> bool:
        """Execute gripper command."""
        cmd = command.get('command', 'unknown')
        print(f"Executing gripper command: {cmd}")

        # Simulate gripper action delay
        time.sleep(0.5)

        # In real implementation, this would control actual gripper
        return True

    def _execute_velocity(self, command: Dict) -> bool:
        """Execute velocity command."""
        linear_x = command.get('linear_x', 0.0)
        angular_z = command.get('angular_z', 0.0)
        duration = command.get('duration', 1.0)

        print(f"Moving with linear: {linear_x}, angular: {angular_z} for {duration}s")

        # Simulate motion
        time.sleep(duration)

        # In real implementation, this would publish to cmd_vel
        return True

    def _execute_speak(self, command: Dict) -> bool:
        """Execute speech command."""
        message = command.get('message', '')
        print(f"Speaking: {message}")

        # Simulate speech delay
        time.sleep(len(message.split()) * 0.1)  # 0.1s per word

        return True

    def _execute_wait(self, command: Dict) -> bool:
        """Execute wait command."""
        duration = command.get('duration', 1.0)
        print(f"Waiting for {duration} seconds")

        time.sleep(duration)
        return True

    def _execute_request_info(self, command: Dict) -> bool:
        """Execute information request."""
        request = command.get('request', '')
        print(f"Requesting information: {request}")

        # In real implementation, this would trigger human interaction
        return True

    def _execute_update_robot_state(self, command: Dict) -> bool:
        """Update robot state."""
        # This would update the robot's internal state representation
        attached = command.get('attached_object')
        detached = command.get('detach_object')

        if attached:
            print(f"Attached object: {attached}")
        if detached:
            print(f"Detached object: {detached}")

        return True

    def _handle_error(self, error_msg: str):
        """Handle execution errors."""
        print(f"Execution error: {error_msg}")
        self._notify_callbacks('error_occurred', {'error': error_msg})

        # Log error
        self.execution_history.append({
            'timestamp': time.time(),
            'type': 'error',
            'message': error_msg
        })

    def _notify_callbacks(self, event_type: str, data: Dict):
        """Notify registered callbacks."""
        for callback in self.callbacks.get(event_type, []):
            try:
                callback(data)
            except Exception as e:
                print(f"Error in {event_type} callback: {e}")

    def register_callback(self, event_type: str, callback: Callable):
        """Register a callback for execution events."""
        if event_type in self.callbacks:
            self.callbacks[event_type].append(callback)
        else:
            print(f"Unknown event type: {event_type}")

    def cancel_execution(self):
        """Cancel current plan execution."""
        if self.current_status == ExecutionStatus.RUNNING:
            self.current_status = ExecutionStatus.CANCELLED
            print("Plan execution cancelled")

    def get_execution_status(self) -> Dict:
        """Get current execution status."""
        return {
            'status': self.current_status.value,
            'current_step': self.current_step,
            'total_steps': len(self.current_plan) if self.current_plan else 0,
            'plan_id': id(self.current_plan) if self.current_plan else None
        }
```

## ROS 2 Action Execution Node

```python
# action_execution_node.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Bool
from geometry_msgs.msg import Twist, PoseStamped
from action_msgs.msg import GoalStatus
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
from threading import Lock
import json
from action_grounding import ActionGrounding
from plan_execution import PlanExecutor

class ActionExecutionNode(Node):
    def __init__(self):
        super().__init__('action_execution_node')

        # Initialize components
        robot_specs = {
            'max_linear_velocity': 0.5,
            'max_angular_velocity': 1.0,
            'manipulation_range': 1.0,
            'gripper_max_width': 0.1,
            'battery_capacity': 100.0
        }

        self.action_grounding = ActionGrounding(robot_specs)
        self.plan_executor = PlanExecutor(self.action_grounding)

        # Publishers and subscribers
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.goal_pub = self.create_publisher(PoseStamped, '/move_base_simple/goal', 10)
        self.status_pub = self.create_publisher(String, '/execution_status', 10)
        self.feedback_pub = self.create_publisher(String, '/execution_feedback', 10)

        # Command subscribers
        self.plan_sub = self.create_subscription(
            String, '/llm_plan', self.plan_callback, 10)
        self.cancel_sub = self.create_subscription(
            Bool, '/cancel_execution', self.cancel_callback, 10)

        # Environment state (simplified)
        self.environment_state = {
            'robot_state': {
                'position': [0.0, 0.0, 0.0],
                'battery_level': 1.0,
                'attached_objects': [],
                'available_actions': ['navigate', 'pick_up', 'place', 'push', 'report']
            },
            'locations': {
                'kitchen': {'position': [2.0, 0.0, 0.0], 'orientation': [0, 0, 0, 1]},
                'office': {'position': [0.0, 2.0, 0.0], 'orientation': [0, 0, 0, 1]},
                'entrance': {'position': [-2.0, 0.0, 0.0], 'orientation': [0, 0, 0, 1]}
            },
            'objects': {
                'coffee': {
                    'name': 'coffee',
                    'position': [2.1, 0.1, 0.0],
                    'category': 'drink',
                    'properties': {'color': 'brown', 'size': 'small'}
                },
                'book': {
                    'name': 'book',
                    'position': [0.1, 2.1, 0.0],
                    'category': 'office_supply',
                    'properties': {'color': 'blue', 'size': 'medium'}
                }
            }
        }

        # Execution state
        self.current_execution_id = 0
        self.execution_lock = Lock()

        # Register callbacks
        self.plan_executor.register_callback('step_completed', self._on_step_completed)
        self.plan_executor.register_callback('plan_completed', self._on_plan_completed)
        self.plan_executor.register_callback('error_occurred', self._on_error_occurred)

        self.get_logger().info('Action Execution Node initialized')

    def plan_callback(self, msg):
        """Handle incoming plan from LLM."""
        try:
            plan_data = json.loads(msg.data)
            plan = plan_data.get('plan', [])
            command = plan_data.get('command', 'unknown')

            self.get_logger().info(f'Executing plan for command: {command}')
            self.get_logger().info(f'Plan has {len(plan)} steps')

            # Execute plan in a separate thread to avoid blocking
            import threading
            thread = threading.Thread(
                target=self._execute_plan_thread,
                args=(plan, command),
                daemon=True
            )
            thread.start()

        except json.JSONDecodeError:
            self.get_logger().error(f'Invalid JSON in plan message: {msg.data}')
        except Exception as e:
            self.get_logger().error(f'Error processing plan: {e}')

    def _execute_plan_thread(self, plan, command):
        """Execute plan in separate thread."""
        with self.execution_lock:
            self.current_execution_id += 1
            execution_id = self.current_execution_id

            # Update status
            status_msg = String()
            status_msg.data = f"Starting execution of plan for: {command}"
            self.status_pub.publish(status_msg)

            # Execute the plan
            result = self.plan_executor.execute_plan(plan, self.environment_state)

            # Publish final status
            final_status = String()
            final_status.data = f"Plan execution completed with status: {result.value}"
            self.status_pub.publish(final_status)

    def cancel_callback(self, msg):
        """Handle execution cancellation."""
        if msg.data:  # Cancel requested
            self.plan_executor.cancel_execution()
            self.get_logger().info('Execution cancellation requested')

    def _on_step_completed(self, data):
        """Handle step completion callback."""
        feedback_msg = String()
        feedback_msg.data = f"Completed step {data['step'] + 1}: {data['action'].get('action', 'unknown')}"
        self.feedback_pub.publish(feedback_msg)

        self.get_logger().info(f"Step completed: {feedback_msg.data}")

    def _on_plan_completed(self, data):
        """Handle plan completion callback."""
        status_msg = String()
        status_msg.data = f"Plan completed - Status: {data['status']}, Steps: {data['steps_completed']}/{data['total_steps']}"
        self.status_pub.publish(status_msg)

        self.get_logger().info(f"Plan completed: {status_msg.data}")

    def _on_error_occurred(self, data):
        """Handle error callback."""
        error_msg = String()
        error_msg.data = f"Execution error: {data['error']}"
        self.status_pub.publish(error_msg)

        self.get_logger().error(f"Execution error: {data['error']}")

    def update_robot_position(self, new_position):
        """Update robot position in environment state."""
        with self.execution_lock:
            self.environment_state['robot_state']['position'] = list(new_position)

    def update_battery_level(self, new_level):
        """Update battery level in environment state."""
        with self.execution_lock:
            self.environment_state['robot_state']['battery_level'] = new_level

    def attach_object(self, obj_name):
        """Add object to attached objects."""
        with self.execution_lock:
            if obj_name not in self.environment_state['robot_state']['attached_objects']:
                self.environment_state['robot_state']['attached_objects'].append(obj_name)

    def detach_object(self, obj_name):
        """Remove object from attached objects."""
        with self.execution_lock:
            if obj_name in self.environment_state['robot_state']['attached_objects']:
                self.environment_state['robot_state']['attached_objects'].remove(obj_name)

def main(args=None):
    rclpy.init(args=args)
    node = ActionExecutionNode()

    # Use multi-threaded executor to handle callbacks properly
    executor = MultiThreadedExecutor()
    executor.add_node(node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Plan Monitoring and Adaptation

```python
# plan_monitoring.py
import time
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum

class PlanDeviationType(Enum):
    """Types of plan deviations."""
    EXECUTION_FAILURE = "execution_failure"
    ENVIRONMENT_CHANGE = "environment_change"
    PERFORMANCE_ISSUE = "performance_issue"
    SAFETY_VIOLATION = "safety_violation"

@dataclass
class PlanDeviation:
    """Represents a deviation from the expected plan execution."""
    deviation_type: PlanDeviationType
    timestamp: float
    description: str
    severity: str  # 'low', 'medium', 'high', 'critical'
    suggested_action: str

class PlanMonitor:
    """Monitors plan execution and detects deviations."""

    def __init__(self, plan_executor):
        self.plan_executor = plan_executor
        self.deviation_history = []
        self.performance_thresholds = {
            'step_duration': 30.0,  # seconds
            'total_plan_time': 300.0,  # seconds
            'battery_threshold': 0.2  # 20%
        }
        self.safety_thresholds = {
            'min_distance_to_obstacle': 0.3,  # meters
            'max_angular_velocity': 1.0,  # rad/s
            'max_linear_velocity': 0.5  # m/s
        }
        self.callbacks = {
            'deviation_detected': [],
            'plan_adapted': [],
            'emergency_stop': []
        }

    def monitor_execution(self, plan: List[Dict], env_state: Dict) -> List[PlanDeviation]:
        """Monitor plan execution and detect deviations."""
        deviations = []

        # Monitor execution progress
        start_time = time.time()
        step_start_times = {}

        # In a real implementation, this would run continuously
        # For this example, we'll check post-execution
        status = self.plan_executor.get_execution_status()

        # Check for execution failures
        if status['status'] == 'failed':
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.EXECUTION_FAILURE,
                timestamp=time.time(),
                description="Plan execution failed",
                severity="high",
                suggested_action="Review plan and environment, retry or abort"
            ))

        # Check for performance issues
        total_time = time.time() - start_time
        if total_time > self.performance_thresholds['total_plan_time']:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.PERFORMANCE_ISSUE,
                timestamp=time.time(),
                description=f"Plan took too long: {total_time:.1f}s > {self.performance_thresholds['total_plan_time']}s",
                severity="medium",
                suggested_action="Optimize plan or adjust expectations"
            ))

        # Check battery level
        battery_level = env_state.get('robot_state', {}).get('battery_level', 1.0)
        if battery_level < self.performance_thresholds['battery_threshold']:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.PERFORMANCE_ISSUE,
                timestamp=time.time(),
                description=f"Low battery: {battery_level:.1%}",
                severity="high",
                suggested_action="Recharge robot or modify plan to include charging"
            ))

        # Store deviations
        self.deviation_history.extend(deviations)

        # Notify callbacks
        for deviation in deviations:
            self._notify_callbacks('deviation_detected', deviation)

        return deviations

    def detect_environment_changes(self, current_env: Dict, expected_env: Dict) -> List[PlanDeviation]:
        """Detect changes in environment that affect plan execution."""
        deviations = []

        # Check for new obstacles
        current_obstacles = current_env.get('obstacles', set())
        expected_obstacles = expected_env.get('obstacles', set())

        new_obstacles = current_obstacles - expected_obstacles
        if new_obstacles:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.ENVIRONMENT_CHANGE,
                timestamp=time.time(),
                description=f"New obstacles detected: {new_obstacles}",
                severity="high",
                suggested_action="Recalculate navigation paths"
            ))

        # Check for missing expected objects
        current_objects = set(current_env.get('objects', {}).keys())
        expected_objects = set(expected_env.get('objects', {}).keys())

        missing_objects = expected_objects - current_objects
        if missing_objects:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.ENVIRONMENT_CHANGE,
                timestamp=time.time(),
                description=f"Expected objects not found: {missing_objects}",
                severity="medium",
                suggested_action="Update plan to account for missing objects"
            ))

        return deviations

    def detect_safety_violations(self, robot_state: Dict, sensor_data: Dict) -> List[PlanDeviation]:
        """Detect safety violations during execution."""
        deviations = []

        # Check distance to obstacles
        min_distance = sensor_data.get('min_obstacle_distance', float('inf'))
        if min_distance < self.safety_thresholds['min_distance_to_obstacle']:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.SAFETY_VIOLATION,
                timestamp=time.time(),
                description=f"Too close to obstacle: {min_distance:.2f}m < {self.safety_thresholds['min_distance_to_obstacle']}m",
                severity="critical",
                suggested_action="Immediate stop and replan"
            ))

        # Check velocities
        current_linear_vel = robot_state.get('linear_velocity', 0.0)
        current_angular_vel = robot_state.get('angular_velocity', 0.0)

        if abs(current_linear_vel) > self.safety_thresholds['max_linear_velocity']:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.SAFETY_VIOLATION,
                timestamp=time.time(),
                description=f"Linear velocity too high: {current_linear_vel:.2f} > {self.safety_thresholds['max_linear_velocity']}",
                severity="high",
                suggested_action="Reduce velocity"
            ))

        if abs(current_angular_vel) > self.safety_thresholds['max_angular_velocity']:
            deviations.append(PlanDeviation(
                deviation_type=PlanDeviationType.SAFETY_VIOLATION,
                timestamp=time.time(),
                description=f"Angular velocity too high: {current_angular_vel:.2f} > {self.safety_thresholds['max_angular_velocity']}",
                severity="high",
                suggested_action="Reduce angular velocity"
            ))

        return deviations

    def adapt_plan(self, original_plan: List[Dict], deviations: List[PlanDeviation]) -> Optional[List[Dict]]:
        """Adapt plan based on detected deviations."""
        if not deviations:
            return original_plan

        # Categorize deviations by severity
        critical_deviations = [d for d in deviations if d.severity == 'critical']
        high_deviations = [d for d in deviations if d.severity == 'high']
        medium_deviations = [d for d in deviations if d.severity == 'medium']

        # Handle critical deviations first
        if critical_deviations:
            self._notify_callbacks('emergency_stop', critical_deviations)
            return None  # Emergency stop required

        # For other deviations, try to adapt the plan
        adapted_plan = original_plan.copy()

        for deviation in deviations:
            if deviation.deviation_type == PlanDeviationType.ENVIRONMENT_CHANGE:
                # Recalculate paths around new obstacles
                adapted_plan = self._adapt_for_obstacles(adapted_plan)
            elif deviation.deviation_type == PlanDeviationType.EXECUTION_FAILURE:
                # Retry or skip failed steps
                adapted_plan = self._adapt_for_failure(adapted_plan, deviation)
            elif deviation.deviation_type == PlanDeviationType.PERFORMANCE_ISSUE:
                # Optimize for performance
                adapted_plan = self._adapt_for_performance(adapted_plan)

        self._notify_callbacks('plan_adapted', {
            'original_plan': original_plan,
            'adapted_plan': adapted_plan,
            'deviations': deviations
        })

        return adapted_plan

    def _adapt_for_obstacles(self, plan: List[Dict]) -> List[Dict]:
        """Adapt plan for new obstacles."""
        # In a real implementation, this would recalculate navigation paths
        # For now, we'll just add a note to the plan
        adapted_plan = []
        for step in plan:
            if step.get('action') == 'navigate_to':
                # Add obstacle avoidance to navigation steps
                step['avoid_obstacles'] = True
            adapted_plan.append(step)
        return adapted_plan

    def _adapt_for_failure(self, plan: List[Dict], deviation: PlanDeviation) -> List[Dict]:
        """Adapt plan for execution failures."""
        # For this example, we'll skip the problematic step
        # In practice, you might have more sophisticated retry logic
        return plan  # Placeholder - implement based on specific failure type

    def _adapt_for_performance(self, plan: List[Dict]) -> List[Dict]:
        """Adapt plan for performance issues."""
        # Optimize plan for better performance
        return plan  # Placeholder - implement optimization logic

    def _notify_callbacks(self, event_type: str, data):
        """Notify registered callbacks."""
        for callback in self.callbacks.get(event_type, []):
            try:
                callback(data)
            except Exception as e:
                print(f"Error in {event_type} callback: {e}")

    def register_callback(self, event_type: str, callback: Callable):
        """Register a callback for monitoring events."""
        if event_type in self.callbacks:
            self.callbacks[event_type].append(callback)
        else:
            print(f"Unknown event type: {event_type}")

# Example usage
def demonstrate_plan_monitoring():
    """Demonstrate plan monitoring capabilities."""
    from action_grounding import ActionGrounding
    from plan_execution import PlanExecutor

    # Initialize components
    robot_specs = {
        'max_linear_velocity': 0.5,
        'max_angular_velocity': 1.0,
        'manipulation_range': 1.0,
        'gripper_max_width': 0.1,
        'battery_capacity': 100.0
    }

    action_grounding = ActionGrounding(robot_specs)
    plan_executor = PlanExecutor(action_grounding)
    plan_monitor = PlanMonitor(plan_executor)

    # Example plan
    example_plan = [
        {'action': 'navigate_to', 'target': 'kitchen'},
        {'action': 'pick_up', 'target': 'coffee'},
        {'action': 'navigate_to', 'target': 'office'},
        {'action': 'place', 'target': 'coffee', 'location': 'table'}
    ]

    # Example environment state
    env_state = {
        'robot_state': {
            'position': [0.0, 0.0, 0.0],
            'battery_level': 0.8,
            'attached_objects': [],
            'available_actions': ['navigate', 'pick_up', 'place', 'push', 'report']
        },
        'locations': {
            'kitchen': {'position': [2.0, 0.0, 0.0], 'orientation': [0, 0, 0, 1]},
            'office': {'position': [0.0, 2.0, 0.0], 'orientation': [0, 0, 0, 1]}
        },
        'objects': {
            'coffee': {
                'name': 'coffee',
                'position': [2.1, 0.1, 0.0],
                'category': 'drink',
                'properties': {'color': 'brown', 'size': 'small'}
            }
        }
    }

    # Execute and monitor
    result = plan_executor.execute_plan(example_plan, env_state)
    deviations = plan_monitor.monitor_execution(example_plan, env_state)

    print(f"Plan execution result: {result}")
    print(f"Deviations detected: {len(deviations)}")

if __name__ == "__main__":
    demonstrate_plan_monitoring()
```

## Next Steps

In the final chapter of Module 4, we'll integrate all the components we've developed into a complete Vision-Language-Action system. We'll cover the deployment considerations, testing strategies, and real-world applications of these advanced robotic systems.